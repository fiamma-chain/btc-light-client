{
  "language": "Solidity",
  "sources": {
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IMessageLibManager } from \"./IMessageLibManager.sol\";\nimport { IMessagingComposer } from \"./IMessagingComposer.sol\";\nimport { IMessagingChannel } from \"./IMessagingChannel.sol\";\nimport { IMessagingContext } from \"./IMessagingContext.sol\";\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options;\n    bool payInLzToken;\n}\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\nstruct Origin {\n    uint32 srcEid;\n    bytes32 sender;\n    uint64 nonce;\n}\n\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\n\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\n\n    event PacketDelivered(Origin origin, address receiver);\n\n    event LzReceiveAlert(\n        address indexed receiver,\n        address indexed executor,\n        Origin origin,\n        bytes32 guid,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    event LzTokenSet(address token);\n\n    event DelegateSet(address sender, address delegate);\n\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\n\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\n\n    function setLzToken(address _lzToken) external;\n\n    function lzToken() external view returns (address);\n\n    function nativeToken() external view returns (address);\n\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { Origin } from \"./ILayerZeroEndpointV2.sol\";\n\ninterface ILayerZeroReceiver {\n    function allowInitializePath(Origin calldata _origin) external view returns (bool);\n\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\n\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nstruct SetConfigParam {\n    uint32 eid;\n    uint32 configType;\n    bytes config;\n}\n\ninterface IMessageLibManager {\n    struct Timeout {\n        address lib;\n        uint256 expiry;\n    }\n\n    event LibraryRegistered(address newLib);\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\n\n    function registerLibrary(address _lib) external;\n\n    function isRegisteredLibrary(address _lib) external view returns (bool);\n\n    function getRegisteredLibraries() external view returns (address[] memory);\n\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\n\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\n\n    /// ------------------- OApp interfaces -------------------\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\n\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\n\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\n\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\n\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\n\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view returns (bytes memory config);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingChannel {\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n\n    function eid() external view returns (uint32);\n\n    // this is an emergency function if a message cannot be verified for some reasons\n    // required to provide _nextNonce to avoid race condition\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\n\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\n\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\n\n    function inboundPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) external view returns (bytes32);\n\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingComposer {\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\n    event LzComposeAlert(\n        address indexed from,\n        address indexed to,\n        address indexed executor,\n        bytes32 guid,\n        uint16 index,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    function composeQueue(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index\n    ) external view returns (bytes32 messageHash);\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingContext {\n    function isSendingMessage() external view returns (bool);\n\n    function getSendContext() external view returns (uint32 dstEid, address sender);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary AddressCast {\n    error AddressCast_InvalidSizeForAddress();\n    error AddressCast_InvalidAddress();\n\n    function toBytes32(bytes calldata _addressBytes) internal pure returns (bytes32 result) {\n        if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n        result = bytes32(_addressBytes);\n        unchecked {\n            uint256 offset = 32 - _addressBytes.length;\n            result = result >> (offset * 8);\n        }\n    }\n\n    function toBytes32(address _address) internal pure returns (bytes32 result) {\n        result = bytes32(uint256(uint160(_address)));\n    }\n\n    function toBytes(bytes32 _addressBytes32, uint256 _size) internal pure returns (bytes memory result) {\n        if (_size == 0 || _size > 32) revert AddressCast_InvalidSizeForAddress();\n        result = new bytes(_size);\n        unchecked {\n            uint256 offset = 256 - _size * 8;\n            assembly {\n                mstore(add(result, 32), shl(offset, _addressBytes32))\n            }\n        }\n    }\n\n    function toAddress(bytes32 _addressBytes32) internal pure returns (address result) {\n        result = address(uint160(uint256(_addressBytes32)));\n    }\n\n    function toAddress(bytes calldata _addressBytes) internal pure returns (address result) {\n        if (_addressBytes.length != 20) revert AddressCast_InvalidAddress();\n        result = address(bytes20(_addressBytes));\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroEndpointV2 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\n/**\n * @title IOAppCore\n */\ninterface IOAppCore {\n    // Custom error messages\n    error OnlyPeer(uint32 eid, bytes32 sender);\n    error NoPeer(uint32 eid);\n    error InvalidEndpointCall();\n    error InvalidDelegate();\n\n    // Event emitted when a peer (OApp) is set for a corresponding endpoint\n    event PeerSet(uint32 eid, bytes32 peer);\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     */\n    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);\n\n    /**\n     * @notice Retrieves the LayerZero endpoint associated with the OApp.\n     * @return iEndpoint The LayerZero endpoint as an interface.\n     */\n    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);\n\n    /**\n     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.\n     */\n    function peers(uint32 _eid) external view returns (bytes32 peer);\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) external;\n\n    /**\n     * @notice Sets the delegate address for the OApp Core.\n     * @param _delegate The address of the delegate to be set.\n     */\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Struct representing enforced option parameters.\n */\nstruct EnforcedOptionParam {\n    uint32 eid; // Endpoint ID\n    uint16 msgType; // Message Type\n    bytes options; // Additional options\n}\n\n/**\n * @title IOAppOptionsType3\n * @dev Interface for the OApp with Type 3 Options, allowing the setting and combining of enforced options.\n */\ninterface IOAppOptionsType3 {\n    // Custom error message for invalid options\n    error InvalidOptions(bytes options);\n\n    // Event emitted when enforced options are set\n    event EnforcedOptionSet(EnforcedOptionParam[] _enforcedOptions);\n\n    /**\n     * @notice Sets enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) external;\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OApp message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) external view returns (bytes memory options);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ILayerZeroReceiver, Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\";\n\ninterface IOAppReceiver is ILayerZeroReceiver {\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement a separate composeMsg sender that is NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata _origin,\n        bytes calldata _message,\n        address _sender\n    ) external view returns (bool isSender);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/libs/OAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppOptionsType3, EnforcedOptionParam } from \"../interfaces/IOAppOptionsType3.sol\";\n\n/**\n * @title OAppOptionsType3\n * @dev Abstract contract implementing the IOAppOptionsType3 interface with type 3 options.\n */\nabstract contract OAppOptionsType3 is IOAppOptionsType3, Ownable {\n    uint16 internal constant OPTION_TYPE_3 = 3;\n\n    // @dev The \"msgType\" should be defined in the child contract.\n    mapping(uint32 eid => mapping(uint16 msgType => bytes enforcedOption)) public enforcedOptions;\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) public virtual onlyOwner {\n        _setEnforcedOptions(_enforcedOptions);\n    }\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function _setEnforcedOptions(EnforcedOptionParam[] memory _enforcedOptions) internal virtual {\n        for (uint256 i = 0; i < _enforcedOptions.length; i++) {\n            // @dev Enforced options are only available for optionType 3, as type 1 and 2 dont support combining.\n            _assertOptionsType3(_enforcedOptions[i].options);\n            enforcedOptions[_enforcedOptions[i].eid][_enforcedOptions[i].msgType] = _enforcedOptions[i].options;\n        }\n\n        emit EnforcedOptionSet(_enforcedOptions);\n    }\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OAPP message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     *\n     * @dev If there is an enforced lzReceive option:\n     * - {gasLimit: 200k, msg.value: 1 ether} AND a caller supplies a lzReceive option: {gasLimit: 100k, msg.value: 0.5 ether}\n     * - The resulting options will be {gasLimit: 300k, msg.value: 1.5 ether} when the message is executed on the remote lzReceive() function.\n     * @dev This presence of duplicated options is handled off-chain in the verifier/executor.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) public view virtual returns (bytes memory) {\n        bytes memory enforced = enforcedOptions[_eid][_msgType];\n\n        // No enforced options, pass whatever the caller supplied, even if it's empty or legacy type 1/2 options.\n        if (enforced.length == 0) return _extraOptions;\n\n        // No caller options, return enforced\n        if (_extraOptions.length == 0) return enforced;\n\n        // @dev If caller provided _extraOptions, must be type 3 as its the ONLY type that can be combined.\n        if (_extraOptions.length >= 2) {\n            _assertOptionsType3(_extraOptions);\n            // @dev Remove the first 2 bytes containing the type from the _extraOptions and combine with enforced.\n            return bytes.concat(enforced, _extraOptions[2:]);\n        }\n\n        // No valid set of options was found.\n        revert InvalidOptions(_extraOptions);\n    }\n\n    /**\n     * @dev Internal function to assert that options are of type 3.\n     * @param _options The options to be checked.\n     */\n    function _assertOptionsType3(bytes memory _options) internal pure virtual {\n        uint16 optionsType;\n        assembly {\n            optionsType := mload(add(_options, 2))\n        }\n        if (optionsType != OPTION_TYPE_3) revert InvalidOptions(_options);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/libs/ReadCodecV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nstruct EVMCallRequestV1 {\n    uint16 appRequestLabel; // Label identifying the application or type of request (can be use in lzCompute)\n    uint32 targetEid; // Target endpoint ID (representing a target blockchain)\n    bool isBlockNum; // True if the request = block number, false if timestamp\n    uint64 blockNumOrTimestamp; // Block number or timestamp to use in the request\n    uint16 confirmations; // Number of block confirmations on top of the requested block number or timestamp before the view function can be called\n    address to; // Address of the target contract on the target chain\n    bytes callData; // Calldata for the contract call\n}\n\nstruct EVMCallComputeV1 {\n    uint8 computeSetting; // Compute setting (0 = map only, 1 = reduce only, 2 = map reduce)\n    uint32 targetEid; // Target endpoint ID (representing a target blockchain)\n    bool isBlockNum; // True if the request = block number, false if timestamp\n    uint64 blockNumOrTimestamp; // Block number or timestamp to use in the request\n    uint16 confirmations; // Number of block confirmations on top of the requested block number or timestamp before the view function can be called\n    address to; // Address of the target contract on the target chain\n}\n\nlibrary ReadCodecV1 {\n    using SafeCast for uint256;\n\n    uint16 internal constant CMD_VERSION = 1;\n\n    uint8 internal constant REQUEST_VERSION = 1;\n    uint16 internal constant RESOLVER_TYPE_SINGLE_VIEW_EVM_CALL = 1;\n\n    uint8 internal constant COMPUTE_VERSION = 1;\n    uint16 internal constant COMPUTE_TYPE_SINGLE_VIEW_EVM_CALL = 1;\n\n    error InvalidVersion();\n    error InvalidType();\n\n    function decode(\n        bytes calldata _cmd\n    )\n        internal\n        pure\n        returns (uint16 appCmdLabel, EVMCallRequestV1[] memory evmCallRequests, EVMCallComputeV1 memory compute)\n    {\n        uint256 offset = 0;\n        uint16 cmdVersion = uint16(bytes2(_cmd[offset:offset + 2]));\n        offset += 2;\n        if (cmdVersion != CMD_VERSION) revert InvalidVersion();\n\n        appCmdLabel = uint16(bytes2(_cmd[offset:offset + 2]));\n        offset += 2;\n\n        (evmCallRequests, offset) = decodeRequestsV1(_cmd, offset);\n\n        // decode the compute if it exists\n        if (offset < _cmd.length) {\n            (compute, ) = decodeEVMCallComputeV1(_cmd, offset);\n        }\n    }\n\n    function decodeRequestsV1(\n        bytes calldata _cmd,\n        uint256 _offset\n    ) internal pure returns (EVMCallRequestV1[] memory evmCallRequests, uint256 newOffset) {\n        newOffset = _offset;\n        uint16 requestCount = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n        newOffset += 2;\n\n        evmCallRequests = new EVMCallRequestV1[](requestCount);\n        for (uint16 i = 0; i < requestCount; i++) {\n            uint8 requestVersion = uint8(_cmd[newOffset]);\n            newOffset += 1;\n            if (requestVersion != REQUEST_VERSION) revert InvalidVersion();\n\n            uint16 appRequestLabel = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n            newOffset += 2;\n\n            uint16 resolverType = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n            newOffset += 2;\n\n            if (resolverType == RESOLVER_TYPE_SINGLE_VIEW_EVM_CALL) {\n                (EVMCallRequestV1 memory request, uint256 nextOffset) = decodeEVMCallRequestV1(\n                    _cmd,\n                    newOffset,\n                    appRequestLabel\n                );\n                newOffset = nextOffset;\n                evmCallRequests[i] = request;\n            } else {\n                revert InvalidType();\n            }\n        }\n    }\n\n    function decodeEVMCallRequestV1(\n        bytes calldata _cmd,\n        uint256 _offset,\n        uint16 _appRequestLabel\n    ) internal pure returns (EVMCallRequestV1 memory request, uint256 newOffset) {\n        newOffset = _offset;\n        request.appRequestLabel = _appRequestLabel;\n\n        uint16 requestSize = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n        newOffset += 2;\n        request.targetEid = uint32(bytes4(_cmd[newOffset:newOffset + 4]));\n        newOffset += 4;\n        request.isBlockNum = uint8(_cmd[newOffset]) == 1;\n        newOffset += 1;\n        request.blockNumOrTimestamp = uint64(bytes8(_cmd[newOffset:newOffset + 8]));\n        newOffset += 8;\n        request.confirmations = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n        newOffset += 2;\n        request.to = address(bytes20(_cmd[newOffset:newOffset + 20]));\n        newOffset += 20;\n        uint16 callDataSize = requestSize - 35;\n        request.callData = _cmd[newOffset:newOffset + callDataSize];\n        newOffset += callDataSize;\n    }\n\n    function decodeEVMCallComputeV1(\n        bytes calldata _cmd,\n        uint256 _offset\n    ) internal pure returns (EVMCallComputeV1 memory compute, uint256 newOffset) {\n        newOffset = _offset;\n        uint8 computeVersion = uint8(_cmd[newOffset]);\n        newOffset += 1;\n        if (computeVersion != COMPUTE_VERSION) revert InvalidVersion();\n        uint16 computeType = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n        newOffset += 2;\n        if (computeType != COMPUTE_TYPE_SINGLE_VIEW_EVM_CALL) revert InvalidType();\n\n        compute.computeSetting = uint8(_cmd[newOffset]);\n        newOffset += 1;\n        compute.targetEid = uint32(bytes4(_cmd[newOffset:newOffset + 4]));\n        newOffset += 4;\n        compute.isBlockNum = uint8(_cmd[newOffset]) == 1;\n        newOffset += 1;\n        compute.blockNumOrTimestamp = uint64(bytes8(_cmd[newOffset:newOffset + 8]));\n        newOffset += 8;\n        compute.confirmations = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n        newOffset += 2;\n        compute.to = address(bytes20(_cmd[newOffset:newOffset + 20]));\n        newOffset += 20;\n    }\n\n    function decodeCmdAppLabel(bytes calldata _cmd) internal pure returns (uint16) {\n        uint256 offset = 0;\n        uint16 cmdVersion = uint16(bytes2(_cmd[offset:offset + 2]));\n        offset += 2;\n        if (cmdVersion != CMD_VERSION) revert InvalidVersion();\n\n        return uint16(bytes2(_cmd[offset:offset + 2]));\n    }\n\n    function decodeRequestV1AppRequestLabel(bytes calldata _request) internal pure returns (uint16) {\n        uint256 offset = 0;\n        uint8 requestVersion = uint8(_request[offset]);\n        offset += 1;\n        if (requestVersion != REQUEST_VERSION) revert InvalidVersion();\n\n        return uint16(bytes2(_request[offset:offset + 2]));\n    }\n\n    function encode(\n        uint16 _appCmdLabel,\n        EVMCallRequestV1[] memory _evmCallRequests,\n        EVMCallComputeV1 memory _evmCallCompute\n    ) internal pure returns (bytes memory) {\n        bytes memory cmd = encode(_appCmdLabel, _evmCallRequests);\n        if (_evmCallCompute.targetEid != 0) {\n            // if eid is 0, it means no compute\n            cmd = appendEVMCallComputeV1(cmd, _evmCallCompute);\n        }\n        return cmd;\n    }\n\n    function encode(\n        uint16 _appCmdLabel,\n        EVMCallRequestV1[] memory _evmCallRequests\n    ) internal pure returns (bytes memory) {\n        bytes memory cmd = abi.encodePacked(CMD_VERSION, _appCmdLabel, _evmCallRequests.length.toUint16());\n        for (uint256 i = 0; i < _evmCallRequests.length; i++) {\n            cmd = appendEVMCallRequestV1(cmd, _evmCallRequests[i]);\n        }\n        return cmd;\n    }\n\n    // todo: optimize this with Buffer\n    function appendEVMCallRequestV1(\n        bytes memory _cmd,\n        EVMCallRequestV1 memory _request\n    ) internal pure returns (bytes memory) {\n        bytes memory newCmd = abi.encodePacked(\n            _cmd,\n            REQUEST_VERSION,\n            _request.appRequestLabel,\n            RESOLVER_TYPE_SINGLE_VIEW_EVM_CALL,\n            (_request.callData.length + 35).toUint16(),\n            _request.targetEid\n        );\n        return\n            abi.encodePacked(\n                newCmd,\n                _request.isBlockNum,\n                _request.blockNumOrTimestamp,\n                _request.confirmations,\n                _request.to,\n                _request.callData\n            );\n    }\n\n    function appendEVMCallComputeV1(\n        bytes memory _cmd,\n        EVMCallComputeV1 memory _compute\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _cmd,\n                COMPUTE_VERSION,\n                COMPUTE_TYPE_SINGLE_VIEW_EVM_CALL,\n                _compute.computeSetting,\n                _compute.targetEid,\n                _compute.isBlockNum,\n                _compute.blockNumOrTimestamp,\n                _compute.confirmations,\n                _compute.to\n            );\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the 'MessagingFee' and 'MessagingReceipt' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppSender, MessagingFee, MessagingReceipt } from \"./OAppSender.sol\";\n// @dev Import the 'Origin' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppReceiver, Origin } from \"./OAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OApp\n * @dev Abstract contract serving as the base for OApp implementation, combining OAppSender and OAppReceiver functionality.\n */\nabstract contract OApp is OAppSender, OAppReceiver {\n    /**\n     * @dev Constructor to initialize the OApp with the provided endpoint and owner.\n     * @param _endpoint The address of the LOCAL LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(address _endpoint, address _delegate) OAppCore(_endpoint, _delegate) {}\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol implementation.\n     * @return receiverVersion The version of the OAppReceiver.sol implementation.\n     */\n    function oAppVersion()\n        public\n        pure\n        virtual\n        override(OAppSender, OAppReceiver)\n        returns (uint64 senderVersion, uint64 receiverVersion)\n    {\n        return (SENDER_VERSION, RECEIVER_VERSION);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppCore, ILayerZeroEndpointV2 } from \"./interfaces/IOAppCore.sol\";\n\n/**\n * @title OAppCore\n * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.\n */\nabstract contract OAppCore is IOAppCore, Ownable {\n    // The LayerZero endpoint associated with the given OApp\n    ILayerZeroEndpointV2 public immutable endpoint;\n\n    // Mapping to store peers associated with corresponding endpoints\n    mapping(uint32 eid => bytes32 peer) public peers;\n\n    /**\n     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.\n     * @param _endpoint The address of the LOCAL Layer Zero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     *\n     * @dev The delegate typically should be set as the owner of the contract.\n     */\n    constructor(address _endpoint, address _delegate) {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n\n        if (_delegate == address(0)) revert InvalidDelegate();\n        endpoint.setDelegate(_delegate);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\n        _setPeer(_eid, _peer);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function _setPeer(uint32 _eid, bytes32 _peer) internal virtual {\n        peers[_eid] = _peer;\n        emit PeerSet(_eid, _peer);\n    }\n\n    /**\n     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.\n     * ie. the peer is set to bytes32(0).\n     * @param _eid The endpoint ID.\n     * @return peer The address of the peer associated with the specified endpoint.\n     */\n    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {\n        bytes32 peer = peers[_eid];\n        if (peer == bytes32(0)) revert NoPeer(_eid);\n        return peer;\n    }\n\n    /**\n     * @notice Sets the delegate address for the OApp.\n     * @param _delegate The address of the delegate to be set.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\n     */\n    function setDelegate(address _delegate) public onlyOwner {\n        endpoint.setDelegate(_delegate);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OAppRead.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { AddressCast } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol\";\n\nimport { OApp } from \"./OApp.sol\";\n\nabstract contract OAppRead is OApp {\n    constructor(address _endpoint, address _delegate) OApp(_endpoint, _delegate) {}\n\n    // -------------------------------\n    // Only Owner\n    function setReadChannel(uint32 _channelId, bool _active) public virtual onlyOwner {\n        _setPeer(_channelId, _active ? AddressCast.toBytes32(address(this)) : bytes32(0));\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IOAppReceiver, Origin } from \"./interfaces/IOAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppReceiver\n * @dev Abstract contract implementing the ILayerZeroReceiver interface and extending OAppCore for OApp receivers.\n */\nabstract contract OAppReceiver is IOAppReceiver, OAppCore {\n    // Custom error message for when the caller is not the registered endpoint/\n    error OnlyEndpoint(address addr);\n\n    // @dev The version of the OAppReceiver implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant RECEIVER_VERSION = 2;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppSender version. Indicates that the OAppSender is not implemented.\n     * ie. this is a RECEIVE only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions.\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (0, RECEIVER_VERSION);\n    }\n\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @dev _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @dev _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata /*_origin*/,\n        bytes calldata /*_message*/,\n        address _sender\n    ) public view virtual returns (bool) {\n        return _sender == address(this);\n    }\n\n    /**\n     * @notice Checks if the path initialization is allowed based on the provided origin.\n     * @param origin The origin information containing the source endpoint and sender address.\n     * @return Whether the path has been initialized.\n     *\n     * @dev This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.\n     * @dev This defaults to assuming if a peer has been set, its initialized.\n     * Can be overridden by the OApp if there is other logic to determine this.\n     */\n    function allowInitializePath(Origin calldata origin) public view virtual returns (bool) {\n        return peers[origin.srcEid] == origin.sender;\n    }\n\n    /**\n     * @notice Retrieves the next nonce for a given source endpoint and sender address.\n     * @dev _srcEid The source endpoint ID.\n     * @dev _sender The sender address.\n     * @return nonce The next nonce.\n     *\n     * @dev The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.\n     * @dev Is required by the off-chain executor to determine the OApp expects msg execution is ordered.\n     * @dev This is also enforced by the OApp.\n     * @dev By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.\n     */\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64 nonce) {\n        return 0;\n    }\n\n    /**\n     * @dev Entry point for receiving messages or packets from the endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The payload of the received message.\n     * @param _executor The address of the executor for the received message.\n     * @param _extraData Additional arbitrary data provided by the corresponding executor.\n     *\n     * @dev Entry point for receiving msg/packet from the LayerZero endpoint.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) public payable virtual {\n        // Ensures that only the endpoint can attempt to lzReceive() messages to this OApp.\n        if (address(endpoint) != msg.sender) revert OnlyEndpoint(msg.sender);\n\n        // Ensure that the sender matches the expected peer for the source endpoint.\n        if (_getPeerOrRevert(_origin.srcEid) != _origin.sender) revert OnlyPeer(_origin.srcEid, _origin.sender);\n\n        // Call the internal OApp implementation of lzReceive.\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to implement lzReceive logic without needing to copy the basic parameter validation.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OAppSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppSender\n * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.\n */\nabstract contract OAppSender is OAppCore {\n    using SafeERC20 for IERC20;\n\n    // Custom error messages\n    error NotEnoughNative(uint256 msgValue);\n    error LzTokenUnavailable();\n\n    // @dev The version of the OAppSender implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant SENDER_VERSION = 1;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.\n     * ie. this is a SEND only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (SENDER_VERSION, 0);\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.\n     * @return fee The calculated MessagingFee for the message.\n     *      - nativeFee: The native fee for the message.\n     *      - lzTokenFee: The LZ token fee for the message.\n     */\n    function _quote(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        bool _payInLzToken\n    ) internal view virtual returns (MessagingFee memory fee) {\n        return\n            endpoint.quote(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),\n                address(this)\n            );\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _fee The calculated LayerZero fee for the message.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.\n     * @return receipt The receipt for the sent message.\n     *      - guid: The unique identifier for the sent message.\n     *      - nonce: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     */\n    function _lzSend(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        MessagingFee memory _fee,\n        address _refundAddress\n    ) internal virtual returns (MessagingReceipt memory receipt) {\n        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.\n        uint256 messageValue = _payNative(_fee.nativeFee);\n        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);\n\n        return\n            // solhint-disable-next-line check-send-result\n            endpoint.send{ value: messageValue }(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),\n                _refundAddress\n            );\n    }\n\n    /**\n     * @dev Internal function to pay the native fee associated with the message.\n     * @param _nativeFee The native fee to be paid.\n     * @return nativeFee The amount of native currency paid.\n     *\n     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,\n     * this will need to be overridden because msg.value would contain multiple lzFees.\n     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.\n     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.\n     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.\n     */\n    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\n        return _nativeFee;\n    }\n\n    /**\n     * @dev Internal function to pay the LZ token fee associated with the message.\n     * @param _lzTokenFee The LZ token fee to be paid.\n     *\n     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.\n     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().\n     */\n    function _payLzToken(uint256 _lzTokenFee) internal virtual {\n        // @dev Cannot cache the token because it is not immutable in the endpoint.\n        address lzToken = endpoint.lzToken();\n        if (lzToken == address(0)) revert LzTokenUnavailable();\n\n        // Pay LZ token fee by sending tokens to the endpoint.\n        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n     *\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n     */\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "src/BtcMirror.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./Endian.sol\";\nimport \"./interfaces/IBtcMirror.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n//\n//                                        #\n//                                       # #\n//                                      # # #\n//                                     # # # #\n//                                    # # # # #\n//                                   # # # # # #\n//                                  # # # # # # #\n//                                 # # # # # # # #\n//                                # # # # # # # # #\n//                               # # # # # # # # # #\n//                              # # # # # # # # # # #\n//                                   # # # # # #\n//                               +        #        +\n//                                ++++         ++++\n//                                  ++++++ ++++++\n//                                    +++++++++\n//                                      +++++\n//                                        +\n//\n// BtcMirror lets you prove that a Bitcoin transaction executed, on Ethereum. It\n// does this by running an on-chain light client.\n//\n// Anyone can submit block headers to BtcMirror. The contract verifies\n// proof-of-work, keeping only the longest chain it has seen. As long as 50% of\n// Bitcoin hash power is honest and at least one person is running the submitter\n// script, the BtcMirror contract always reports the current canonical Bitcoin\n// chain.\ncontract BtcMirror is IBtcMirror, OwnableUpgradeable {\n    /**\n     * @notice Emitted whenever the contract accepts a new heaviest chain.\n     */\n    event NewTip(uint256 blockHeight, uint256 blockTime, bytes32 blockHash);\n\n    /**\n     * @notice Emitted only after a difficulty retarget, when the contract\n     *         accepts a new heaviest chain with updated difficulty.\n     */\n    event NewTotalDifficultySinceRetarget(\n        uint256 blockHeight,\n        uint256 totalDifficulty,\n        uint32 newDifficultyBits\n    );\n\n    /**\n     * @notice Emitted when we reorg out a portion of the chain.\n     */\n    event Reorg(uint256 count, bytes32 oldTip, bytes32 newTip);\n\n    uint256 private latestBlockHeight;\n\n    uint256 private latestBlockTime;\n\n    mapping(uint256 => bytes32) private blockHeightToHash;\n\n    /**\n     * @notice Difficulty targets in each retargeting period.\n     */\n    mapping(uint256 => uint256) public periodToTarget;\n\n    /**\n     * @notice Whether we're tracking testnet or mainnet Bitcoin.\n     */\n    bool public isTestnet;\n\n    /**\n     * @notice Constructor for the logic contract\n     * @dev Disables initializers to prevent direct initialization of the logic contract.\n     *      This is a security measure for upgradeable contracts deployed behind proxies.\n     *      The logic contract should only be initialized through the proxy.\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract.\n     *          Tracks Bitcoin starting from a given block. The isTestnet\n     *          argument is necessary because the Bitcoin testnet does not\n     *          respect the difficulty rules, so we disable block difficulty\n     *          checks in order to track it.\n     */\n    function initialize(\n        address _admin,\n        uint256 _blockHeight,\n        bytes32 _blockHash,\n        uint256 _blockTime,\n        uint256 _expectedTarget,\n        bool _isTestnet\n    ) external initializer {\n        require(_admin != address(0), \"Invalid admin address\");\n        __Ownable_init(_admin);\n\n        blockHeightToHash[_blockHeight] = _blockHash;\n        latestBlockHeight = _blockHeight;\n        latestBlockTime = _blockTime;\n        periodToTarget[_blockHeight / 2016] = _expectedTarget;\n        isTestnet = _isTestnet;\n    }\n\n    /**\n     * @notice Returns the Bitcoin block hash at a specific height.\n     */\n    function getBlockHash(uint256 number) public view returns (bytes32) {\n        return blockHeightToHash[number];\n    }\n\n    /**\n     * @notice Returns the height of the current chain tip.\n     */\n    function getLatestBlockHeight() public view returns (uint256) {\n        return latestBlockHeight;\n    }\n\n    /**\n     * @notice Returns the timestamp of the current chain tip.\n     */\n    function getLatestBlockTime() public view returns (uint256) {\n        return latestBlockTime;\n    }\n\n    /**\n     * @notice Returns latest block height and specific block hash in one call\n     * @dev This is optimized for LayerZero cross-chain reads to reduce call count\n     * @param blockNumber The specific block number to get hash for\n     * @return latestHeight The latest block height\n     * @return requestedBlockNumber The requested block number\n     * @return blockHash The hash of the requested block\n     */\n    function getLatestHeightAndBlockHash(\n        uint256 blockNumber\n    )\n        public\n        view\n        returns (\n            uint256 latestHeight,\n            uint256 requestedBlockNumber,\n            bytes32 blockHash\n        )\n    {\n        return (latestBlockHeight, blockNumber, blockHeightToHash[blockNumber]);\n    }\n    /**\n     * @notice Allows the owner to submit a new Bitcoin chain segment.\n     *         This function is only callable by the owner.\n     * @dev This function is used to submit new blocks to the BtcMirror contract.\n     *      It verifies the block headers and updates the state accordingly.\n     */\n\n    function submit_uncheck(\n        uint256 blockHeight,\n        bytes calldata blockHeaders,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external onlyOwner {\n        bytes32 hash = keccak256(abi.encode(blockHeight, blockHeaders));\n        address expected_addr = ecrecover(hash, v, r, s);\n        require(expected_addr == msg.sender, \"Invalid signature\");\n\n        uint256 numHeaders = blockHeaders.length / 80;\n        require(numHeaders * 80 == blockHeaders.length, \"wrong header length\");\n        require(numHeaders > 0, \"must submit at least one block\");\n\n        uint256 newHeight = blockHeight + numHeaders - 1;\n        for (uint256 i = 0; i < numHeaders; i++) {\n            bytes calldata blockHeader = blockHeaders[80 * i:80 * (i + 1)];\n            uint256 blockNum = blockHeight + i;\n            uint256 blockHashNum = Endian.reverse256(\n                uint256(sha256(abi.encode(sha256(blockHeader))))\n            );\n            blockHeightToHash[blockNum] = bytes32(blockHashNum);\n\n            if (blockNum % 2016 == 0) {\n                bytes32 bits = bytes32(blockHeader[72:76]);\n                uint256 target = getTarget(bits);\n                periodToTarget[blockNum / 2016] = target;\n            }\n        }\n\n        latestBlockHeight = newHeight;\n        latestBlockTime = Endian.reverse32(\n            uint32(\n                bytes4(\n                    blockHeaders[blockHeaders.length - 12:blockHeaders.length -\n                        8]\n                )\n            )\n        );\n\n        bytes32 newTip = getBlockHash(newHeight);\n        emit NewTip(newHeight, latestBlockTime, newTip);\n    }\n\n    /**\n     * @notice Validates a Bitcoin block header\n     * @param header 80-byte block header data\n     * @param blockHeight block height\n     * @return true if the block header is valid, false otherwise\n     */\n    function validateHeader(\n        bytes calldata header,\n        uint256 blockHeight\n    ) public view returns (bool) {\n        require(header.length == 80, \"wrong header length\");\n        require(blockHeight > 0, \"The genesis block cannot be validated\");\n\n        // 1. Validate block hash calculation\n        uint256 blockHashNum = Endian.reverse256(\n            uint256(sha256(abi.encode(sha256(header))))\n        );\n\n        // 2. Validate previous block hash\n        bytes32 prevHash = bytes32(\n            Endian.reverse256(uint256(bytes32(header[4:36])))\n        );\n\n        // Check if previous block exists\n        if (blockHeightToHash[blockHeight - 1] == bytes32(0)) {\n            return false;\n        }\n\n        // Check if previous block hash matches\n        if (prevHash != blockHeightToHash[blockHeight - 1]) {\n            return false;\n        }\n\n        // 3. Validate proof of work and difficulty target\n        bytes32 bits = bytes32(header[72:76]);\n        uint256 target = getTarget(bits);\n\n        // 4. Validate difficulty target\n        uint256 period = blockHeight / 2016;\n        if (blockHeight % 2016 == 0) {\n            // For difficulty adjustment blocks, validate the adjustment is legal\n            uint256 lastTarget = periodToTarget[period - 1];\n            if (!isTestnet && target >> 2 >= lastTarget) {\n                // Difficulty decreased by more than 75%\n                return false;\n            }\n        } else if (!isTestnet && target != periodToTarget[period]) {\n            // For non-adjustment blocks, validate difficulty matches current period\n            return false;\n        }\n\n        // 5. Validate block hash meets difficulty requirement\n        if (blockHashNum >= target) {\n            return false;\n        }\n\n        // 6. Validate version number\n        uint32 version = Endian.reverse32(uint32(bytes4(header[0:4])));\n        if (version < 2) {\n            return false;\n        }\n\n        // 7. Validate Merkle Root\n        bytes32 merkleRoot = bytes32(\n            Endian.reverse256(uint256(bytes32(header[36:68])))\n        );\n        if (merkleRoot == bytes32(0)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Challenges a previously submitted block by proving it's invalid, and submit the correct chain.\n     * @dev This function allows anyone to challenge a block by providing evidence that it violates Bitcoin consensus rules.\n     *      The challenger must provide:\n     *      1. The owner's signature to prevent spam\n     *      2. The invalid block headers\n     *      3. The index of the specific invalid block\n     *      4. A valid alternative chain\n     *      If the challenge is successful (i.e., the block is proven invalid), the alternative chain is accepted.\n     *\n     * @param wrong_idx Index of the invalid block in the wrongBlockHeaders array\n     * @param wrongBlockHeaders Array of block headers containing the invalid block\n     * @param v Recovery byte of the owner's signature\n     * @param r R component of the owner's signature\n     * @param s S component of the owner's signature\n     * @param blockHeight Starting height of the alternative chain\n     * @param blockHeaders Alternative valid chain to replace the invalid one\n     *\n     * @custom:security-note The owner's signature is required to prevent DoS attacks through excessive challenges\n     */\n    function challenge(\n        uint256 wrong_idx,\n        bytes calldata wrongBlockHeaders,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint256 blockHeight,\n        bytes calldata blockHeaders\n    ) external {\n        address owner = owner();\n        bytes32 hash = keccak256(abi.encode(blockHeight, wrongBlockHeaders));\n        address expected_addr = ecrecover(hash, v, r, s);\n        require(expected_addr == owner, \"Challenger use wrong signature\");\n        require(blockHeight > 0, \"The genesis block cannot be challenged\");\n\n        uint256 numWrongHeaders = wrongBlockHeaders.length / 80;\n        require(\n            numWrongHeaders * 80 == wrongBlockHeaders.length,\n            \"wrong header length\"\n        );\n        require(numWrongHeaders > 0, \"must submit at least one block\");\n\n        bytes calldata wrongHeader = wrongBlockHeaders[80 * wrong_idx:80 *\n            (wrong_idx + 1)];\n        uint256 wrongBlockHeight = blockHeight + wrong_idx;\n\n        // Validate the challenged block header\n        bool isValid = validateHeader(wrongHeader, wrongBlockHeight);\n        require(!isValid, \"The challenged block appears to be valid\");\n\n        // submit the correct chain\n        submit(blockHeight, blockHeaders);\n    }\n\n    /**\n     * Submits a new Bitcoin chain segment. Must be heavier (not necessarily\n     * longer) than the chain rooted at getBlockHash(getLatestBlockHeight()).\n     */\n    function submit(uint256 blockHeight, bytes calldata blockHeaders) private {\n        uint256 numHeaders = blockHeaders.length / 80;\n        require(numHeaders * 80 == blockHeaders.length, \"wrong header length\");\n        require(numHeaders > 0, \"must submit at least one block\");\n\n        // sanity check: the new chain must not end in a past difficulty period\n        // (BtcMirror does not support a 2-week reorg)\n        uint256 oldPeriod = latestBlockHeight / 2016;\n        uint256 newHeight = blockHeight + numHeaders - 1;\n        uint256 newPeriod = newHeight / 2016;\n        require(newPeriod >= oldPeriod, \"old difficulty period\");\n\n        // if we crossed a retarget, do extra math to compare chain weight\n        uint256 parentPeriod = (blockHeight - 1) / 2016;\n        uint256 oldWork = 0;\n        if (newPeriod > parentPeriod) {\n            assert(newPeriod == parentPeriod + 1);\n            // the submitted chain segment contains a difficulty retarget.\n            if (newPeriod == oldPeriod) {\n                // the old canonical chain is past the retarget\n                // we cannot compare length, we must compare total work\n                oldWork = getWorkInPeriod(oldPeriod, latestBlockHeight);\n            } else {\n                // the old canonical chain is before the retarget\n                assert(oldPeriod == parentPeriod);\n            }\n        }\n\n        // verify and store each block\n        bytes32 oldTip = getBlockHash(latestBlockHeight);\n        uint256 nReorg = 0;\n        for (uint256 i = 0; i < numHeaders; i++) {\n            uint256 blockNum = blockHeight + i;\n            nReorg += submitBlock(blockNum, blockHeaders[80 * i:80 * (i + 1)]);\n        }\n\n        // check that we have a new heaviest chain\n        if (newPeriod > parentPeriod) {\n            // the submitted chain segment crosses into a new difficulty\n            // period. this is happens once every ~2 weeks. check total work\n            bytes calldata lastHeader = blockHeaders[80 * (numHeaders - 1):];\n            uint32 newDifficultyBits = Endian.reverse32(\n                uint32(bytes4(lastHeader[72:76]))\n            );\n\n            uint256 newWork = getWorkInPeriod(newPeriod, newHeight);\n            require(newWork > oldWork, \"insufficient total difficulty\");\n\n            // erase any block hashes above newHeight, now invalidated.\n            // (in case we just accepted a shorter, heavier chain.)\n            for (uint256 i = newHeight + 1; i <= latestBlockHeight; i++) {\n                blockHeightToHash[i] = 0;\n            }\n\n            emit NewTotalDifficultySinceRetarget(\n                newHeight,\n                newWork,\n                newDifficultyBits\n            );\n        } else {\n            // here we know what newPeriod == oldPeriod == parentPeriod\n            // with identical per-block difficulty. just keep the longest chain.\n            assert(newPeriod == oldPeriod);\n            assert(newPeriod == parentPeriod);\n            require(newHeight > latestBlockHeight, \"insufficient chain length\");\n        }\n\n        // record the new tip height and timestamp\n        latestBlockHeight = newHeight;\n        uint256 ixT = blockHeaders.length - 12;\n        uint32 time = uint32(bytes4(blockHeaders[ixT:ixT + 4]));\n        latestBlockTime = Endian.reverse32(time);\n\n        // finally, log the new tip\n        bytes32 newTip = getBlockHash(newHeight);\n        emit NewTip(newHeight, latestBlockTime, newTip);\n        if (nReorg > 0) {\n            emit Reorg(nReorg, oldTip, newTip);\n        }\n    }\n\n    function getWorkInPeriod(\n        uint256 period,\n        uint256 height\n    ) private view returns (uint256) {\n        uint256 target = periodToTarget[period];\n        uint256 workPerBlock = (2 ** 256 - 1) / target;\n\n        uint256 numBlocks = height - (period * 2016) + 1;\n        assert(numBlocks >= 1 && numBlocks <= 2016);\n\n        return numBlocks * workPerBlock;\n    }\n\n    function submitBlock(\n        uint256 blockHeight,\n        bytes calldata blockHeader\n    ) private returns (uint256 numReorged) {\n        // compute the block hash\n        assert(blockHeader.length == 80);\n        uint256 blockHashNum = Endian.reverse256(\n            uint256(sha256(abi.encode(sha256(blockHeader))))\n        );\n\n        // optimistically save the block hash\n        // we'll revert if the header turns out to be invalid\n        bytes32 oldHash = blockHeightToHash[blockHeight];\n        bytes32 newHash = bytes32(blockHashNum);\n        if (oldHash != bytes32(0) && oldHash != newHash) {\n            // if we're overwriting a non-zero block hash, that block is reorged\n            numReorged = 1;\n        }\n        // this is the most expensive line. 20,000 gas to use a new storage slot\n        blockHeightToHash[blockHeight] = newHash;\n\n        // verify previous hash\n        bytes32 prevHash = bytes32(\n            Endian.reverse256(uint256(bytes32(blockHeader[4:36])))\n        );\n        require(prevHash == blockHeightToHash[blockHeight - 1], \"bad parent\");\n        require(prevHash != bytes32(0), \"parent block not yet submitted\");\n\n        // verify proof-of-work\n        bytes32 bits = bytes32(blockHeader[72:76]);\n        uint256 target = getTarget(bits);\n        require(blockHashNum < target, \"block hash above target\");\n\n        // support once-every-2016-blocks retargeting\n        uint256 period = blockHeight / 2016;\n        if (blockHeight % 2016 == 0) {\n            // Bitcoin enforces a minimum difficulty of 25% of the previous\n            // difficulty. Doing the full calculation here does not necessarily\n            // add any security. We keep the heaviest chain, not the longest.\n            uint256 lastTarget = periodToTarget[period - 1];\n            // ignore difficulty update rules on testnet.\n            // Bitcoin testnet has some clown hacks regarding difficulty, see\n            // https://blog.lopp.net/the-block-storms-of-bitcoins-testnet/\n            if (!isTestnet) {\n                require(target >> 2 < lastTarget, \"<25% difficulty retarget\");\n            }\n            periodToTarget[period] = target;\n        } else if (!isTestnet) {\n            // verify difficulty\n            require(target == periodToTarget[period], \"wrong difficulty bits\");\n        }\n    }\n\n    function getTarget(bytes32 bits) public pure returns (uint256) {\n        // Bitcoin represents difficulty using a custom floating-point big int\n        // representation. the \"difficulty bits\" consist of an 8-bit exponent\n        // and a 24-bit mantissa, which combine to generate a u256 target. the\n        // block hash must be below the target.\n        uint256 exp = uint8(bits[3]);\n        uint256 mantissa = uint8(bits[2]);\n        mantissa = (mantissa << 8) | uint8(bits[1]);\n        mantissa = (mantissa << 8) | uint8(bits[0]);\n        uint256 target = mantissa << (8 * (exp - 3));\n        return target;\n    }\n}\n"
    },
    "src/BtcProofUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./Endian.sol\";\nimport \"./interfaces/BtcTxProof.sol\";\nimport \"./interfaces/IBtcTxVerifier.sol\";\n\n/**\n * @dev A parsed (but NOT fully validated) Bitcoin transaction.\n */\nstruct BitcoinTx {\n    /**\n     * @dev Whether we successfully parsed this Bitcoin TX, valid version etc.\n     *      Does NOT check signatures or whether inputs are unspent.\n     */\n    bool validFormat;\n    /**\n     * @dev Version. Must be 1 or 2.\n     */\n    uint32 version;\n    /**\n     * @dev Each input spends a previous UTXO.\n     */\n    BitcoinTxIn[] inputs;\n    /**\n     * @dev Each output creates a new UTXO.\n     */\n    BitcoinTxOut[] outputs;\n    /**\n     * @dev Locktime. Either 0 for no lock, blocks if <500k, or seconds.\n     */\n    uint32 locktime;\n}\n\nstruct BitcoinTxIn {\n    /**\n     * @dev Previous transaction.\n     */\n    uint256 prevTxID;\n    /**\n     * @dev Specific output from that transaction.\n     */\n    uint32 prevTxIndex;\n    /**\n     * @dev Mostly useless for tx v1, BIP68 Relative Lock Time for tx v2.\n     */\n    uint32 seqNo;\n    /**\n     * @dev Input script length\n     */\n    uint32 scriptLen;\n    /**\n     * @dev Input script, spending a previous UTXO. Over 32 bytes unsupported.\n     */\n    bytes32 script;\n}\n\nstruct BitcoinTxOut {\n    /**\n     * @dev TXO value, in satoshis\n     */\n    uint64 valueSats;\n    /**\n     * @dev Output script length\n     */\n    uint32 scriptLen;\n    /**\n     * @dev Output script. Over 32 bytes unsupported.\n     */\n    bytes script;\n}\n\n//\n//                                        #\n//                                       # #\n//                                      # # #\n//                                     # # # #\n//                                    # # # # #\n//                                   # # # # # #\n//                                  # # # # # # #\n//                                 # # # # # # # #\n//                                # # # # # # # # #\n//                               # # # # # # # # # #\n//                              # # # # # # # # # # #\n//                                   # # # # # #\n//                               +        #        +\n//                                ++++         ++++\n//                                  ++++++ ++++++\n//                                    +++++++++\n//                                      +++++\n//                                        +\n//\n// BtcProofUtils provides functions to prove things about Bitcoin transactions.\n// Verifies merkle inclusion proofs, transaction IDs, and payment details.\nlibrary BtcProofUtils {\n    /**\n     * @dev Validates that a given payment appears under a given block hash.\n     *\n     * This verifies all of the following:\n     * 1. Raw transaction really does pay X satoshis to Y script hash.\n     * 2. Raw transaction hashes to the given transaction ID.\n     * 3. Transaction ID appears under transaction root (Merkle proof).\n     * 4. Transaction root is part of the block header.\n     * 5. Block header hashes to a given block hash.\n     *\n     * The caller must separately verify that the block hash is in the chain.\n     *\n     * Always returns true or reverts with a descriptive reason.\n     */\n    function validatePayment(\n        bytes32 blockHash,\n        BtcTxProof calldata txProof,\n        uint256 txOutIx,\n        bytes32 destScriptHash,\n        uint256 satoshisExpected,\n        bool checkOpReturn,\n        uint256 opReturnOutIx,\n        bytes32 opReturnDataExpected\n    ) internal pure returns (bool) {\n        // 1. Block header to block hash\n        require(getBlockHash(txProof.blockHeader) == blockHash, \"Block hash mismatch\");\n\n        // 2. and 3. Transaction ID included in block\n        bytes32 blockTxRoot = getBlockTxMerkleRoot(txProof.blockHeader);\n        bytes32 txRoot = getTxMerkleRoot(txProof.txId, txProof.txIndex, txProof.txMerkleProof);\n        require(blockTxRoot == txRoot, \"Tx merkle root mismatch\");\n\n        // 4. Raw transaction to TxID\n        require(getTxID(txProof.rawTx) == txProof.txId, \"Tx ID mismatch\");\n\n        // 5. Finally, validate raw transaction pays stated recipient.\n        BitcoinTx memory parsedTx = parseBitcoinTx(txProof.rawTx);\n        BitcoinTxOut memory txo = parsedTx.outputs[txOutIx];\n        require(destScriptHash == sha256(txo.script), \"Script mismatch\");\n        require(txo.valueSats == satoshisExpected, \"Amount mismatch\");\n\n        // 6. Check OP_RETURN output if requested\n        if (checkOpReturn) {\n            BitcoinTxOut memory opReturnTxo = parsedTx.outputs[opReturnOutIx];\n            bytes32 opReturnData = getOpReturnScriptData(opReturnTxo.scriptLen, opReturnTxo.script);\n            require(opReturnData == opReturnDataExpected, \"OP_RETURN data mismatch\");\n        }\n\n        // We've verified that blockHash contains a P2SH transaction\n        // that sends at least satoshisExpected to the given hash.\n        return true;\n    }\n\n    function validateInclusion(bytes32 blockHash, TxInclusionProof calldata inclusionProof)\n        internal\n        pure\n        returns (bool)\n    {\n        // 1. Block header to block hash\n        require(getBlockHash(inclusionProof.blockHeader) == blockHash, \"Block hash mismatch\");\n\n        // 2. Raw transaction to TxID\n        bytes32 txId = getTxID(inclusionProof.rawTx);\n\n        // 2. and 3. Transaction ID included in block\n        bytes32 blockTxRoot = getBlockTxMerkleRoot(inclusionProof.blockHeader);\n        bytes32 txRoot = getTxMerkleRoot(txId, inclusionProof.txIndex, inclusionProof.txMerkleProof);\n        require(blockTxRoot == txRoot, \"Tx merkle root mismatch\");\n\n        // 4. We've verified that blockHash contains the transaction\n        return true;\n    }\n\n    /**\n     * @dev Compute a block hash given a block header.\n     */\n    function getBlockHash(bytes calldata blockHeader) public pure returns (bytes32) {\n        require(blockHeader.length == 80, \"Invalid block header length\");\n        bytes32 ret = sha256(abi.encodePacked(sha256(blockHeader)));\n        return bytes32(Endian.reverse256(uint256(ret)));\n    }\n\n    /**\n     * @dev Get the transactions merkle root given a block header.\n     */\n    function getBlockTxMerkleRoot(bytes calldata blockHeader) public pure returns (bytes32) {\n        require(blockHeader.length == 80);\n        return bytes32(blockHeader[36:68]);\n    }\n\n    /**\n     * @dev Recomputes the transactions root given a merkle proof.\n     */\n    function getTxMerkleRoot(bytes32 txId, uint256 txIndex, bytes calldata siblings) public pure returns (bytes32) {\n        bytes32 ret = bytes32(Endian.reverse256(uint256(txId)));\n        uint256 len = siblings.length / 32;\n        for (uint256 i = 0; i < len; i++) {\n            bytes32 s = bytes32(Endian.reverse256(uint256(bytes32(siblings[i * 32:(i + 1) * 32]))));\n            if (txIndex & 1 == 0) {\n                ret = doubleSha(abi.encodePacked(ret, s));\n            } else {\n                ret = doubleSha(abi.encodePacked(s, ret));\n            }\n            txIndex = txIndex >> 1;\n        }\n        return ret;\n    }\n\n    /**\n     * @dev Computes the ubiquitious Bitcoin SHA256(SHA256(x))\n     */\n    function doubleSha(bytes memory buf) internal pure returns (bytes32) {\n        return sha256(abi.encodePacked(sha256(buf)));\n    }\n\n    /**\n     * @dev Recomputes the transaction ID for a raw transaction.\n     */\n    function getTxID(bytes calldata rawTransaction) public pure returns (bytes32) {\n        bytes32 ret = doubleSha(rawTransaction);\n        return bytes32(Endian.reverse256(uint256(ret)));\n    }\n\n    /**\n     * @dev Parses a HASH-SERIALIZED Bitcoin transaction.\n     *      This means no flags and no segwit witnesses.\n     */\n    function parseBitcoinTx(bytes calldata rawTx) public pure returns (BitcoinTx memory ret) {\n        ret.version = Endian.reverse32(uint32(bytes4(rawTx[0:4])));\n        if (ret.version < 1 || ret.version > 2) {\n            return ret; // invalid version\n        }\n\n        // Read transaction inputs\n        uint256 offset = 4;\n        uint256 nInputs;\n        (nInputs, offset) = readVarInt(rawTx, offset);\n        ret.inputs = new BitcoinTxIn[](nInputs);\n        for (uint256 i = 0; i < nInputs; i++) {\n            BitcoinTxIn memory txIn;\n            txIn.prevTxID = Endian.reverse256(uint256(bytes32(rawTx[offset:offset + 32])));\n            offset += 32;\n            txIn.prevTxIndex = Endian.reverse32(uint32(bytes4(rawTx[offset:offset + 4])));\n            offset += 4;\n            uint256 nInScriptBytes;\n            (nInScriptBytes, offset) = readVarInt(rawTx, offset);\n            require(nInScriptBytes <= 34, \"Scripts over 34 bytes unsupported\");\n            txIn.scriptLen = uint32(nInScriptBytes);\n            txIn.script = bytes32(rawTx[offset:offset + nInScriptBytes]);\n            offset += nInScriptBytes;\n            txIn.seqNo = Endian.reverse32(uint32(bytes4(rawTx[offset:offset + 4])));\n            offset += 4;\n            ret.inputs[i] = txIn;\n        }\n\n        // Read transaction outputs\n        uint256 nOutputs;\n        (nOutputs, offset) = readVarInt(rawTx, offset);\n        ret.outputs = new BitcoinTxOut[](nOutputs);\n        for (uint256 i = 0; i < nOutputs; i++) {\n            BitcoinTxOut memory txOut;\n            txOut.valueSats = Endian.reverse64(uint64(bytes8(rawTx[offset:offset + 8])));\n            offset += 8;\n            uint256 nOutScriptBytes;\n            (nOutScriptBytes, offset) = readVarInt(rawTx, offset);\n            require(nOutScriptBytes <= 34, \"Scripts over 34 bytes unsupported\");\n            txOut.scriptLen = uint32(nOutScriptBytes);\n            txOut.script = rawTx[offset:offset + nOutScriptBytes];\n            offset += nOutScriptBytes;\n            ret.outputs[i] = txOut;\n        }\n\n        // Finally, read locktime, the last four bytes in the tx.\n        ret.locktime = Endian.reverse32(uint32(bytes4(rawTx[offset:offset + 4])));\n        offset += 4;\n        if (offset != rawTx.length) {\n            return ret; // Extra data at end of transaction.\n        }\n\n        // Parsing complete, sanity checks passed, return success.\n        ret.validFormat = true;\n        return ret;\n    }\n\n    /**\n     * Reads a Bitcoin-serialized varint = a u256 serialized in 1-9 bytes.\n     */\n    function readVarInt(bytes calldata buf, uint256 offset) public pure returns (uint256 val, uint256 newOffset) {\n        uint8 pivot = uint8(buf[offset]);\n        if (pivot < 0xfd) {\n            val = pivot;\n            newOffset = offset + 1;\n        } else if (pivot == 0xfd) {\n            val = Endian.reverse16(uint16(bytes2(buf[offset + 1:offset + 3])));\n            newOffset = offset + 3;\n        } else if (pivot == 0xfe) {\n            val = Endian.reverse32(uint32(bytes4(buf[offset + 1:offset + 5])));\n            newOffset = offset + 5;\n        } else {\n            // pivot == 0xff\n            val = Endian.reverse64(uint64(bytes8(buf[offset + 1:offset + 9])));\n            newOffset = offset + 9;\n        }\n    }\n\n    /**\n     * @dev Verifies that `script` is a standard OP_RETURN script, and extracts the data.\n     * @return result The data, or 0 if verification failed.\n     */\n    function getOpReturnScriptData(uint256 scriptLen, bytes memory script) internal pure returns (bytes32 result) {\n        if (scriptLen != 34) {\n            return 0;\n        }\n\n        // index 0: OP_RETURN\n        // index 1: OP_PUSHBYTES_32\n        if (script[0] != 0x6a || script[1] != 0x20) {\n            return 0;\n        }\n\n        assembly {\n            result := mload(add(add(script, 32), 2))\n        }\n    }\n}\n"
    },
    "src/BtcTxVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./interfaces/IBtcMirror.sol\";\nimport \"./interfaces/IBtcTxVerifier.sol\";\nimport \"./BtcProofUtils.sol\";\n\n//\n//                                        #\n//                                       # #\n//                                      # # #\n//                                     # # # #\n//                                    # # # # #\n//                                   # # # # # #\n//                                  # # # # # # #\n//                                 # # # # # # # #\n//                                # # # # # # # # #\n//                               # # # # # # # # # #\n//                              # # # # # # # # # # #\n//                                   # # # # # #\n//                               +        #        +\n//                                ++++         ++++\n//                                  ++++++ ++++++\n//                                    +++++++++\n//                                      +++++\n//                                        +\n//\n// BtcVerifier implements a merkle proof that a Bitcoin payment succeeded. It\n// uses BtcMirror as a source of truth for which Bitcoin block hashes are in the\n// canonical chain.\ncontract BtcTxVerifier is IBtcTxVerifier {\n    IBtcMirror public immutable mirror;\n\n    constructor(address _mirror) {\n        mirror = IBtcMirror(_mirror);\n    }\n\n    function verifyPayment(\n        uint256 minConfirmations,\n        uint256 blockNum,\n        BtcTxProof calldata inclusionProof,\n        uint256 txOutIx,\n        bytes32 destScriptHash,\n        uint256 amountSats,\n        bool checkOpReturn,\n        uint256 opReturnOutIx,\n        bytes32 opReturnData\n    ) external view returns (bool) {\n        checkHeight(blockNum, minConfirmations);\n\n        bytes32 blockHash = mirror.getBlockHash(blockNum);\n        return BtcProofUtils.validatePayment(\n            blockHash, inclusionProof, txOutIx, destScriptHash, amountSats, checkOpReturn, opReturnOutIx, opReturnData\n        );\n    }\n\n    function verifyInclusion(uint256 minConfirmations, uint256 blockNum, TxInclusionProof calldata inclusionProof)\n        external\n        view\n        returns (bool)\n    {\n        checkHeight(blockNum, minConfirmations);\n\n        bytes32 blockHash = mirror.getBlockHash(blockNum);\n        return BtcProofUtils.validateInclusion(blockHash, inclusionProof);\n    }\n\n    function checkHeight(uint256 blockNum, uint256 minConfirmations) internal view {\n        uint256 mirrorHeight = mirror.getLatestBlockHeight();\n        require(mirrorHeight >= blockNum, \"Bitcoin Mirror doesn't have that block yet\");\n        require(mirrorHeight + 1 >= minConfirmations + blockNum, \"Not enough Bitcoin block confirmations\");\n    }\n}\n"
    },
    "src/Endian.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n// Bitwise math helpers for dealing with Bitcoin block headers.\n// Bitcoin block fields are little-endian. Must flip to big-endian for EVM.\nlibrary Endian {\n    function reverse256(uint256 input) internal pure returns (uint256 v) {\n        v = input;\n\n        // swap bytes\n        uint256 pat1 = 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00;\n        v = ((v & pat1) >> 8) | ((v & ~pat1) << 8);\n\n        // swap 2-byte long pairs\n        uint256 pat2 = 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000;\n        v = ((v & pat2) >> 16) | ((v & ~pat2) << 16);\n\n        // swap 4-byte long pairs\n        uint256 pat4 = 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000;\n        v = ((v & pat4) >> 32) | ((v & ~pat4) << 32);\n\n        // swap 8-byte long pairs\n        uint256 pat8 = 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000;\n        v = ((v & pat8) >> 64) | ((v & ~pat8) << 64);\n\n        // swap 16-byte long pairs\n        v = (v >> 128) | (v << 128);\n    }\n\n    function reverse64(uint64 input) internal pure returns (uint64 v) {\n        v = input;\n\n        // swap bytes\n        v = ((v & 0xFF00FF00FF00FF00) >> 8) | ((v & 0x00FF00FF00FF00FF) << 8);\n\n        // swap 2-byte long pairs\n        v = ((v & 0xFFFF0000FFFF0000) >> 16) | ((v & 0x0000FFFF0000FFFF) << 16);\n\n        // swap 4-byte long pairs\n        v = (v >> 32) | (v << 32);\n    }\n\n    function reverse32(uint32 input) internal pure returns (uint32 v) {\n        v = input;\n\n        // swap bytes\n        v = ((v & 0xFF00FF00) >> 8) | ((v & 0x00FF00FF) << 8);\n\n        // swap 2-byte long pairs\n        v = (v >> 16) | (v << 16);\n    }\n\n    function reverse16(uint16 input) internal pure returns (uint16 v) {\n        v = input;\n\n        // swap bytes\n        v = (v >> 8) | (v << 8);\n    }\n}\n"
    },
    "src/interfaces/BtcTxProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @notice Proof that a transaction (rawTx) is in a given block.\n */\nstruct BtcTxProof {\n    /**\n     * @notice 80-byte block header.\n     */\n    bytes blockHeader;\n    /**\n     * @notice Bitcoin transaction ID, equal to SHA256(SHA256(rawTx))\n     */\n    // This is not gas-optimized--we could omit it and compute from rawTx. But\n    //s the cost is minimal, and keeping it allows better revert messages.\n    bytes32 txId;\n    /**\n     * @notice Index of transaction within the block.\n     */\n    uint256 txIndex;\n    /**\n     * @notice Merkle proof. Concatenated sibling hashes, 32*n bytes.\n     */\n    bytes txMerkleProof;\n    /**\n     * @notice Raw transaction, HASH-SERIALIZED, no witnesses.\n     */\n    bytes rawTx;\n}\n\n/**\n * @notice Proof that a transaction (rawTx) is in a given block.\n */\nstruct TxInclusionProof {\n    /**\n     * @notice 80-byte block header.\n     */\n    bytes blockHeader;\n    /**\n     * @notice Index of transaction within the block.\n     */\n    uint256 txIndex;\n    /**\n     * @notice Merkle proof. Concatenated sibling hashes, 32*n bytes.\n     */\n    bytes txMerkleProof;\n    /**\n     * @notice Raw transaction, HASH-SERIALIZED, no witnesses.\n     */\n    bytes rawTx;\n}\n"
    },
    "src/interfaces/IBtcMirror.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @notice Tracks Bitcoin. Provides block hashes.\n */\ninterface IBtcMirror {\n    /**\n     * @notice Returns the Bitcoin block hash at a specific height.\n     */\n    function getBlockHash(uint256 number) external view returns (bytes32);\n\n    /**\n     * @notice Returns the height of the latest block (tip of the chain).\n     */\n    function getLatestBlockHeight() external view returns (uint256);\n\n    /**\n     * @notice Returns the timestamp of the lastest block, as Unix seconds.\n     */\n    function getLatestBlockTime() external view returns (uint256);\n\n    /**\n     * @notice Returns latest block height and specific block hash in one call\n     * @dev This is optimized for LayerZero cross-chain reads to reduce call count\n     * @param blockNumber The specific block number to get hash for\n     * @return latestHeight The latest block height\n     * @return requestedBlockNumber The requested block number\n     * @return blockHash The hash of the requested block\n     */\n    function getLatestHeightAndBlockHash(\n        uint256 blockNumber\n    )\n        external\n        view\n        returns (\n            uint256 latestHeight,\n            uint256 requestedBlockNumber,\n            bytes32 blockHash\n        );\n\n    /**\n     * @notice Submits a new Bitcoin chain segment (80-byte headers) s\n     */\n    function submit_uncheck(\n        uint256 blockHeight,\n        bytes calldata blockHeaders,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @notice Challenges a previously submitted block by proving it's invalid, and submit the correct chain.\n     */\n    function challenge(\n        uint256 wrong_idx,\n        bytes calldata wrongBlockHeaders,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint256 blockHeight,\n        bytes calldata blockHeaders\n    ) external;\n}\n"
    },
    "src/interfaces/IBtcTxVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./BtcTxProof.sol\";\nimport \"./IBtcMirror.sol\";\n\n/**\n * @notice Verifies Bitcoin transaction proofs.\n */\ninterface IBtcTxVerifier {\n    /**\n     * @notice Verifies that the a transaction cleared, paying a given amount to\n     *         a given address. Specifically, verifies a proof that the tx was\n     *         in block N, and that block N has at least M confirmations.\n     *\n     *         Also verifies that if checkOpReturn is true, the transaction has an OP_RETURN output\n     *         with the given data, and that the output is at the given index.\n     */\n    function verifyPayment(\n        uint256 minConfirmations,\n        uint256 blockNum,\n        BtcTxProof calldata inclusionProof,\n        uint256 txOutIx,\n        bytes32 destScriptHash,\n        uint256 amountSats,\n        bool checkOpReturn,\n        uint256 opReturnOutIx,\n        bytes32 opReturnData\n    ) external view returns (bool);\n\n    /**\n     * @notice Returns the underlying mirror associated with this verifier.\n     */\n    function mirror() external view returns (IBtcMirror);\n\n    /**\n     * @notice Verifies that the a transaction is included in a given block.\n     *\n     * @param minConfirmations The minimum number of confirmations required for the block to be considered valid.\n     * @param blockNum The block number to verify inclusion in.\n     * @param inclusionProof The proof of inclusion of the transaction in the block.\n     *\n     * @return True if the transaction is included in the block, false otherwise.\n     */\n    function verifyInclusion(uint256 minConfirmations, uint256 blockNum, TxInclusionProof calldata inclusionProof)\n        external\n        view\n        returns (bool);\n}\n"
    },
    "src/LzBtcMirror.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// Import necessary LayerZero interfaces and contracts\nimport {AddressCast} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol\";\nimport {MessagingFee, MessagingReceipt} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport {Origin} from \"@layerzerolabs/oapp-evm/contracts/oapp/OApp.sol\";\nimport {OAppOptionsType3} from \"@layerzerolabs/oapp-evm/contracts/oapp/libs/OAppOptionsType3.sol\";\nimport {ReadCodecV1, EVMCallRequestV1} from \"@layerzerolabs/oapp-evm/contracts/oapp/libs/ReadCodecV1.sol\";\nimport {OAppRead} from \"@layerzerolabs/oapp-evm/contracts/oapp/OAppRead.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./interfaces/IBtcMirror.sol\";\n\n/// @title LzBtcMirror\n/// @notice A LayerZero OAppRead contract to read Bitcoin block data from target chain BtcMirror\ncontract LzBtcMirror is OAppRead, OAppOptionsType3 {\n    /// @notice Emitted when combined data is received from target chain\n    /// @param blockNumber The requested block number\n    /// @param blockHash The block hash\n    /// @param latestHeight The latest block height\n    event DataReceived(\n        uint256 indexed latestHeight,\n        uint256 indexed blockNumber,\n        bytes32 indexed blockHash\n    );\n\n    /// @notice LayerZero read channel ID\n    uint32 public READ_CHANNEL;\n\n    /// @notice Message type for the read operation.\n    uint16 public constant READ_TYPE = 1;\n\n    /// @notice Target chain ID where BtcMirror is deployed\n    uint32 public immutable targetEid;\n\n    /// @notice BtcMirror contract address on target chain\n    address public immutable targetBtcMirror;\n\n    /// @notice Storage for received data from cross-chain calls\n    mapping(uint256 => bytes32) private receivedBlockHashes;\n    uint256 private receivedLatestHeight;\n\n    /**\n     * @notice Constructor to initialize the LzBtcMirror contract\n     * @param _endpoint The LayerZero endpoint contract address\n     * @param _delegate The address that will have ownership privileges\n     * @param _readChannel The LayerZero read channel ID\n     * @param _targetEid The target chain endpoint ID where BtcMirror is deployed\n     * @param _targetBtcMirror The BtcMirror contract address on target chain\n     */\n    constructor(\n        address _endpoint,\n        address _delegate,\n        uint32 _readChannel,\n        uint32 _targetEid,\n        address _targetBtcMirror\n    ) OAppRead(_endpoint, _delegate) Ownable(_delegate) {\n        READ_CHANNEL = _readChannel;\n        targetEid = _targetEid;\n        targetBtcMirror = _targetBtcMirror;\n        _setPeer(_readChannel, AddressCast.toBytes32(address(this)));\n    }\n\n    // \n    // 0. Quote business logic\n    // \n\n    /**\n     * @notice Estimates the messaging fee required to perform the read operation.\n     * @param blockNumber The Bitcoin block number to read\n     * @param _extraOptions Additional messaging options\n     * @return fee The estimated messaging fee\n     */\n    function quoteReadFee(\n        uint256 blockNumber,\n        bytes calldata _extraOptions\n    ) external view returns (MessagingFee memory fee) {\n        return\n            _quote(\n                READ_CHANNEL,\n                _getCmd(blockNumber),\n                combineOptions(READ_CHANNEL, READ_TYPE, _extraOptions),\n                false\n            );\n    }\n\n    // \n    // 1a. Send business logic\n    // \n\n    /**\n     * @notice Sends a read request to fetch latest height and block hash from target BtcMirror\n     * @dev The caller must send enough ETH to cover the messaging fee\n     * @param blockNumber The Bitcoin block number to get hash for\n     * @param _extraOptions Additional messaging options\n     * @return receipt The LayerZero messaging receipt for the request\n     */\n    function readData(\n        uint256 blockNumber,\n        bytes calldata _extraOptions\n    ) external payable returns (MessagingReceipt memory receipt) {\n        // 1. Build the read command for the target BtcMirror\n        bytes memory cmd = _getCmd(blockNumber);\n\n        // 2. Send the read request via LayerZero\n        return\n            _lzSend(\n                READ_CHANNEL,\n                cmd,\n                combineOptions(READ_CHANNEL, READ_TYPE, _extraOptions),\n                MessagingFee(msg.value, 0),\n                payable(msg.sender)\n            );\n    }\n\n    // \n    // 1b. Read command construction\n    // \n\n    /**\n     * @notice Constructs the read command to fetch latest height and block hash from target chain\n     * @param blockNumber The Bitcoin block number\n     * @return cmd The encoded command that specifies what data to read\n     */\n    function _getCmd(\n        uint256 blockNumber\n    ) internal view returns (bytes memory cmd) {\n        // 1. Define WHAT function to call on the target contract\n        bytes memory callData = abi.encodeWithSelector(\n            IBtcMirror.getLatestHeightAndBlockHash.selector,\n            blockNumber\n        );\n\n        // 2. Build the read request specifying WHERE and HOW to fetch the data\n        EVMCallRequestV1[] memory readRequests = new EVMCallRequestV1[](1);\n        readRequests[0] = EVMCallRequestV1({\n            appRequestLabel: 1,\n            targetEid: targetEid,\n            isBlockNum: false,\n            blockNumOrTimestamp: uint64(block.timestamp),\n            confirmations: 15,\n            to: targetBtcMirror,\n            callData: callData\n        });\n\n        // 3. Encode the complete read command\n        cmd = ReadCodecV1.encode(0, readRequests);\n    }\n\n    // \n    // 2. Receive business logic\n    // \n\n    /**\n     * @notice Handles the received data from target BtcMirror\n     * @param _message The data returned from the read request\n     */\n    function _lzReceive(\n        Origin calldata /*_origin*/,\n        bytes32 /*_guid*/,\n        bytes calldata _message,\n        address /*_executor*/,\n        bytes calldata /*_extraData*/\n    ) internal override {\n        // 1. Decode the returned data (latestHeight, blockNumber, and blockHash)\n        (uint256 latestHeight, uint256 blockNumber, bytes32 blockHash) = abi\n            .decode(_message, (uint256, uint256, bytes32));\n\n        // 2. Store the received data\n        receivedLatestHeight = latestHeight;\n        receivedBlockHashes[blockNumber] = blockHash;\n\n        // 3. Emit an event with the received data\n        emit DataReceived(latestHeight, blockNumber, blockHash);\n    }\n\n    // \n    // 3. View functions for received data (compatible with BtcMirror interface)\n    // \n\n    /**\n     * @notice Get received block hash (compatible with BtcMirror.getBlockHash)\n     * @param number The Bitcoin block number\n     * @return blockHash The received block hash (zero if not received)\n     */\n    function getBlockHash(uint256 number) external view returns (bytes32) {\n        return receivedBlockHashes[number];\n    }\n\n    /**\n     * @notice Get received latest height (compatible with BtcMirror.getLatestBlockHeight)\n     * @return latestHeight The received latest height\n     */\n    function getLatestBlockHeight() external view returns (uint256) {\n        return receivedLatestHeight;\n    }\n\n    /**\n     * @notice Returns latest block height and specific block hash in one call\n     * @dev Compatible with BtcMirror.getLatestHeightAndBlockHash for unified ABI\n     * @param blockNumber The specific block number to get hash for\n     * @return latestHeight The latest block height from received data\n     * @return requestedBlockNumber The requested block number (echoed back)\n     * @return blockHash The hash of the requested block from received data\n     */\n    function getLatestHeightAndBlockHash(\n        uint256 blockNumber\n    )\n        external\n        view\n        returns (\n            uint256 latestHeight,\n            uint256 requestedBlockNumber,\n            bytes32 blockHash\n        )\n    {\n        return (\n            receivedLatestHeight,\n            blockNumber,\n            receivedBlockHashes[blockNumber]\n        );\n    }\n\n    // \n    // 4. Admin functions\n    // \n\n    /**\n     * @notice Sets the LayerZero read channel\n     * @param _channelId The channel ID to set\n     * @param _active Flag to activate or deactivate the channel\n     */\n    function setReadChannel(\n        uint32 _channelId,\n        bool _active\n    ) public override onlyOwner {\n        _setPeer(\n            _channelId,\n            _active ? AddressCast.toBytes32(address(this)) : bytes32(0)\n        );\n        READ_CHANNEL = _channelId;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}